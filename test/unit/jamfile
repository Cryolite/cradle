project cradle/test/unit
  : requirements
    <source>/cradle/ext/boost//headers
    <source>/cradle/ext/boost//unit_test_framework
  ;

import path ;
import regex ;

local .here = [ regex.match "Jamfile<(.*)>" : "$(__name__)" : 1 ] ;
.here = [ path.make "$(.here)" ] ;

local .direct-subdirs ;
for local i in [ path.glob "$(.here)" : * ] {
  if [ path.exists "$(i)/jamfile" ] {
    .direct-subdirs += "$(i:B)" ;
  }
}

# `bjam` will introduce dependency on a path (say, `XXXXX`) into source
# files that have header inclusions `#include <XXXXX>` or `#include "XXXXX"`
# even if `XXXXX` is a relative path to a directory. However, this makes
# trouble. Consider that just one file
# `cradle/test/unit/exception/foo_run.cpp` is modified. This change also
# alters the modification time of directory `cradle/test/unit/exception`.
# Therefore, when `bjam` is invoked with the current directory being
# `cradle/test/unit`, not only the changed file
# `cradle/test/unit/exception/foo_run.cpp` and its dependants but also
# source files that have header inclusions `#include <exception>` or
# `#include "exception"` and its dependants are about to be updated. As a
# result, changes to just one file will propagate to a vast number of
# completely unrelated files.
#
# In order to avoid the above-mentioned problem, an explicit target with an
# obfuscated name inhibits users from invoking `bjam` with the current
# directory being this directory.
alias do_not_invoke_this_target_directly
  : "$(.direct-subdirs)//check"
  ;
explicit do_not_invoke_this_target_directly ;
